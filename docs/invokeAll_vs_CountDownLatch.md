_– `invokeAll` vs `CountDownLatch` 기반 테스트 비교_

서비스에 동시성 제어를 적용한 후, 이를 테스트하기 위한 시나리오를 구성할 때 우리는 흔히 `ExecutorService`의 `invokeAll()` 메서드를 사용한다. 하지만 이 방식이 **정말 '동시에' 요청을 보내는 테스트로 적절할까?** 실제로 테스트를 해보면, 1개의 예약만 성공해야 할 테스트에서 2개 이상 성공하는 현상을 마주할 수 있다.

이번 글에서는 `invokeAll()` 기반 테스트의 한계와, **정확한 동시성을 유도하기 위해 `CountDownLatch`를 사용하는 방식의 차이**를 비교해본다.

---

## 1. `invokeAll()` 기반 테스트의 동작 방식

```kotlin
val executor = Executors.newFixedThreadPool(10)
executor.invokeAll(listOfTasks)
```

`invokeAll()`은 다음 순서로 동작한다:

1. 각 `Callable`을 순회하며 `submit`으로 스레드 풀에 넣는다.
2. 스레드 풀의 **가용한 스레드 수만큼** 작업이 실행된다.
3. 나머지는 **큐에서 대기**한다.
4. 모든 작업이 끝날 때까지 대기한 뒤, 결과를 반환한다.

### ✅ 장점
- 작성이 간단하다.
- 작업 결과를 `Future`로 바로 받을 수 있다.

### ❌ 한계
- **실행 시점이 제각각**이다.
- 스레드 수에 따라 요청 순서가 **자연스럽게 비동기 처리**되며, 완전한 동시 실행이 아니다.
- 정확한 Race Condition 테스트에는 부적합하다.

---

## 2. `CountDownLatch`를 이용한 테스트 방식

```kotlin
val latch = CountDownLatch(1)

val tasks = (1..100).map {
    Callable {
        latch.await() // 출발 신호 대기
        reserveSeatService.reserve(command)
    }
}
```

- 모든 스레드는 `latch.await()`에서 대기한 상태로 준비된다.
- `latch.countDown()`이 호출되면 **모든 스레드가 동시에 출발**한다.
- 이 방식은 실제 환경에서 발생할 수 있는 **동시 다발적인 요청**과 가장 유사한 상황을 재현한다.

---

## 3. 실제 테스트 결과 비교

| 항목 | invokeAll 기반 테스트 | CountDownLatch 기반 테스트 |
|------|------------------------|-----------------------------|
| 최대 동시 실행 수 | 스레드 풀 크기만큼 | 쓰레드 개수만큼 |
| 실행 타이밍 제어 | ❌ 없음 | ✅ 있음 (정확한 동시 출발) |
| 테스트 실패 가능성 | 높음 (동시성 재현 실패) | 낮음 (동시성 재현 용이) |
| 코드 작성 복잡도 | 간단 | 약간 복잡 (Latch 제어 필요) |

---

## 4. 왜 이런 문제가 생겼을까?

`invokeAll()`은 본질적으로 **"동시에 실행되도록 스케줄링"**할 뿐, **"진짜 동시 실행"**은 보장하지 않는다. 예를 들어, 10개의 작업을 실행할 때 스레드 풀 크기가 3이라면, 최초 3개가 실행되고 나머지는 큐에 대기하게 된다.

### → 이때 발생하는 문제:
- **락을 우회하여 중복 예약이 발생할 수 있음**
- **순차적 실행처럼 보이는 테스트 결과로 인해 동시성 이슈를 놓칠 수 있음**

---

## 5. 결론

- **빠르게 구현하고 싶은 간단한 테스트** → `invokeAll()`
- **정확한 동시성 재현이 필요한 테스트** → `CountDownLatch`

**동시성 제어 기능을 테스트하는 경우라면**, 반드시 `CountDownLatch` 기반의 테스트 코드를 작성하여 정확한 race condition을 시뮬레이션해야 한다. 락이 잘 걸리는지, 예외가 잘 발생하는지, 원하는 수의 요청만 성공하는지 등 모든 것이 여기에 달려 있다.
