# Caffeine + Redis + DB 기반의 3단 캐시 구조 설계 및 구현

## 배경

서비스가 고도화되고 트래픽이 증가함에 따라, 데이터베이스의 부하를 줄이기 위한 **캐싱 전략**은 필수적이다. 특히 서버가 다중 인스턴스로 운영되는 **분산 환경**에서는 단순한 로컬 캐시만으로는 캐시 일관성과 활용도가 제한적이다. 본 문서에서는 Caffeine(로컬) → Redis(중앙) → DB로 이어지는 **3단 캐시 계층** 구조를 도입한 이유와 실제 동작 과정을 설명한다.

---

## 설계 목표

- **성능 최적화**: DB 조회 빈도를 최소화
- **확장성 고려**: 서버 수가 늘어나더라도 캐시의 일관성 유지
- **자원 효율성 확보**: Redis는 공유 자원이므로 접근 빈도가 높은 데이터만 저장

---

## 캐시 계층 구조

1. **Caffeine (1차 캐시)**
    - 각 서버 인스턴스 내부에 존재하는 **로컬 캐시**
    - 접근 속도가 가장 빠르며, 자주 조회되는 데이터에 대해 즉시 응답 가능
    - 단점: 인스턴스 재시작 시 캐시 초기화됨

2. **Redis (2차 캐시)**
    - 모든 서버 인스턴스가 공유하는 **중앙 캐시**
    - Caffeine에 없을 경우 조회하며, 다시 Caffeine에 저장하여 이후 요청에 대비
    - 인스턴스 간 데이터 일관성을 유지할 수 있음

3. **Database (3차 저장소)**
    - 캐시에 존재하지 않을 경우 최종적으로 조회하는 원본 저장소
    - 캐시 적중률을 높이기 위한 백업용 데이터 저장소

---

## 캐시 흐름

```text
[Request]
   ↓
[Caffeine] — MISS
   ↓
[Redis] — MISS
   ↓
[DB] — QUERY → 저장 (Caffeine, Redis)
```

---

## 실제 동작 로그 예시

### 서버 첫 요청 시

```
⚠️ [Caffeine MISS] key = movies:all
⚠️ [Redis MISS] key = movies:all
📡 [DB QUERY] key = movies:all
📥 [Caffeine PUT] (from DB) key = movies:all
📦 [Redis PUT] key = movies:all
```

### 두 번째 요청부터는

```
✅ [Caffeine HIT] key = movies:all
```

### 서버 재시작 후에는

```
⚠️ [Caffeine MISS] key = movies:all
✅ [Redis HIT] key = movies:all
📥 [Caffeine PUT] (from Redis) key = movies:all
```

---

## 설계 포인트: 왜 Redis만 쓰지 않고 Caffeine도 쓰는가?

"**서버 이중화**가 된 환경에서 어차피 Redis를 사용한다면, 왜 굳이 Caffeine을 쓰는가?"라는 질문에 대한 답변은 다음과 같다:

- **네트워크 비용** 절감: 로컬 메모리(Caffeine)는 Redis보다 빠르다.
- **Redis의 부하 최소화**: 캐시의 대부분을 로컬에서 처리함으로써 Redis는 자주 호출되는 데이터만 처리한다.
- **효율적 자원 사용**: 다음과 같은 정책을 도입할 수 있다.
    - Caffeine에서 **10회 이상 조회된 데이터**만 Redis에 동기화
    - Redis에는 **인기 데이터만 저장**하여 메모리 사용량을 제어

---

## 결론

이러한 3단 캐시 구조는 단순히 캐시 적중률을 높이는 데 그치지 않고, 분산 환경에서도 **캐시 일관성과 서비스 응답 속도**를 동시에 확보할 수 있는 전략이다. 특히 고트래픽, 고확장성을 고려하는 시스템에서 **Caffeine → Redis → DB** 구조는 강력한 성능 이점을 제공한다.